{
  "hash": "08e57717f11cee0c94c06c1b89b2452f",
  "result": {
    "markdown": "---\ntitle: Thermal Recovery - Part III\nsubtitle: Heat Conduction Ahead of an Advancing Front\nauthor: Farshad Tabasinejad\ndate: '2023-03-18'\ndate-modified: '2021-03-18'\ntoc: true\ndraft: true\ncategories:\n  - julia\n  - thermal recovery\n  - heat conduction\n  - heat loss\nimage: alberta_production_rates.png\nexecute:\n  cache: false\n  output: true\nformat:\n  html:\n    code-fold: false\n    code-tools: false\n    code-overflow: wrap\n    code-block-bg: true\n    code-block-border-left: '#31BAE9'\n    code-copy: hover\n    highlight: zenburn\n---\n\n# Disclaimer\n\nThis blog post is for educational purposes only. Any commercial use of the information provided in this blog post is prohibited. The author is not responsible for any damage or loss caused by the use of the information provided in this blog post. \n\n# Introduction\n\nIn the previous post, we discussed heat conduction into the overburden from a stationary hot surface area. It was extended to a case with the hot source area exapnding over time parallel to the overburden surface. In this post, we will extend the model to include heat conduction ahead of an advancing front moving into the overburden. The model is based on the work of [1]. The problem is a 1D heat conduction model with a moving front. Details of the model can be found in [1]. The model is implemented in Julia and the source code can be downloaded by clicking on **`</>Code`** next to the blog title.\n\n# Heat conduction ahead of an advancing front\n\nIn a steam-assisted gravity drainage (SAGD) process, as the mixture of heated oil and condensate moves downward due to the gravity, the steam chamber expandes to fill in the voidage. A fraction of the stored heat in the chamber will be transfered ahead of the moving chamber into the cold region by conduction. The heat transfer ahead of the advancing front is modeled as a 1D heat conduction problem with a moving front.\n\nThe analytical solution for this problem is given by [1]:\n\n$$\n\\frac {\\partial^{2} T^{*}}{\\partial \\zeta^{2}} + \\frac {\\partial T^{*}}{\\partial \\zeta} = \\frac {\\partial T^{*}}{\\partial t^{*}} \n$$  {#eq-1}\n\nwhere \n$$\nT^{*} = \\frac {T - T_{R}} {T_{s} - T_{R}}\n$$\n\n$$\nt^{*} = \\frac {U^{2}t} {\\alpha}\n$$\n\n$$\n\\zeta^{*} = \\frac {U \\zeta} {U}\n$$\n\nU is the front velocity and $\\zeta$ is the distance from the front and is defined as:\n\n$$\n\\zeta = x - Ut\n$$\n\nThe boundary conditions are:\n\n$$\nT^{*} = 0 \\quad \\text{when} \\quad t = 0 \\quad \\text{for all} \\quad \\zeta^{*}\n$$\n\n$$\nT^{*} = 1 \\quad \\text{when} \\quad \\zeta^{*} = 0 \\quad \\text{and} \\quad \\mathrm t \\gt 0\n$$\n\nSolution of this problem is given by Carslaw and Jaeger [2]:\n\n$$\nT^{*} = \\frac {1}{2} \\left[\\text{erfc} \\left( \\frac {\\zeta^{*} + t^{*}}{\\sqrt{4 \\mathrm t^{*}}} \\right) + e^{-\\zeta^{*}} \\text{erfc} \\left( \\frac {\\zeta^{*} - t^{*}}{\\sqrt{4 \\mathrm t^{*}}} \\right)    \\right]\n$$\n\nwhere $\\text{erfc()}$ is the complementary error function.\n\nFor the steady-state case, (@eq-1) will be simplified to:\n\n$$\n\\frac {\\partial^{2} T^{*}}{\\partial \\zeta^{2}} + \\frac {\\partial T^{*}}{\\partial \\zeta} = 0\n$$  {#eq-2}\n\nThe solution of this problem is given by Carslaw and Jaeger [2]:\n\n$$\nT^{*} = e^{-\\zeta^{*}}\n$$\n\n\nWe now implement both solutions in Julia:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing DataFrames\nusing Plots\nusing StatsPlots \nusing LaTeXStrings\nusing SpecialFunctions\nusing ShiftedArrays\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nfunction Tstar_transient(zeta_star, t_star)\n    return 0.5 * (erfc((zeta_star + t_star) / sqrt(4 * t_star)) + exp(-zeta_star) * erfc((zeta_star - t_star) / sqrt(4 * t_star)))\nend;\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nfunction Tstar_steady_state(zeta_star)\n    return exp(-zeta_star)\nend;\n```\n:::\n\n\nThe solution is plotted below for different values of $t^{*}$.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nzeta_star = range(0, 5, length = 200)\nt_star = [0.1, 0.3, 1.0, 3.0];\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# plot Tstar vs zeta_star for different values of t_star\nplot(zeta_star, Tstar_transient.(zeta_star, t_star[1]), label = \"t* = $(t_star[1])\", \n  legend = :topright, \n  lw = 2, \n  title = \"Conductive temperature profile ahead of an advancing front\")\nfor i in 2:length(t_star)\n    plot!(zeta_star, Tstar_transient.(zeta_star, t_star[i]), \n    lw = 2, \n    label = \"t* = $(t_star[i])\")\nend\nplot!(zeta_star, Tstar_steady_state.(zeta_star),\n    lw = 3, \n    label = \"steady state\")\nxlabel!(L\"\\zeta^{*}\")\nylabel!(L\"T^{*}\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n## Total heat stored ahead of the front at steady state\n\nThe cumulative heat stored ahead of the advancing front at steady state is given by:\n\n$$\n\\frac{Q_{c}}{A} = \\kappa \\frac {(T_{steam} - T_{reservoir})}{U} \n$$\n\nThe following function is calculates the total heat stored ahead of the front at steady state:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nfunction cumulative_heat_flux_stored_steady(U, kappa, T_steam, T_reservoir)\n    return kappa * (T_steam - T_reservoir) / U\nend;\n```\n:::\n\n\n## Total heat stored ahead of the front at transient state\n\nThe total heat stored ahead of the front at transient state is given by:\n\n$$\n\\frac{Q_{c}}{A} = \\kappa \\frac {(T_{steam} - T_{reservoir})}{U} \\int_{0}^{\\infty} T^{*} \\mathrm d \\zeta^{*}\n$$\n\nwhere $T^{*}$ is the temperature profile for the transient case. By substituting the solution for $T^{*}$, the heat integral can be computed as follows:\n\n$$\nHI = \\int_{0}^{\\infty} T^{*} \\mathrm d \\zeta^{*} = \\sqrt \\frac{t^{*}}{\\pi} e^{-t^{*}/4} + (1 + \\frac{t^{*}}{2}) erf(\\sqrt \\frac {t^{*}}{4}) - \\frac{t^{*}}{2}\n$$\n\nFigure below shows the behavior of heat integral with respect to $t^{*}$. At infinity the value of heat integral is equal to the steady state value ($HI_{\\infty} = 1.0$).\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nt_star = range(0, 25, length = 1000);\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nplot(t_star, sqrt.(t_star / pi) .* exp.(-t_star / 4) .+ (1 .+ t_star / 2) .* erf.(sqrt.(t_star / 4)) .- t_star / 2,\n    lw = 3, \n    label = \"Heat Integral\")\nxlabel!(L\"t^{*}\")\nylabel!(\"Heat Integral\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\nThe total heat stored ahead of the front at transient state is calculated as follows:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n# make it broadcastable over t_star\nfunction cumulative_heat_flux_stored_transient(U, kappa, T_steam, T_reservoir, t_star)\n\n    return kappa * (T_steam - T_reservoir) / U * (sqrt.(t_star / pi) .* exp.(-t_star / 4) .+ (1 .+ t_star / 2) .* erf.(sqrt.(t_star / 4)) .- t_star / 2)\nend;\n```\n:::\n\n\n## Example\n\nFollowing the example in previous post and by assuming that the steam chamber spread rapidly over the reservoir (constant surface area), we calculate the total heat stored ahead of the front at transient state for the following parameters:\n\n* $U = 1.5 \\mathrm m/365 \\quad days$\n* $\\alpha = 8.333e-7 * 86400 \\quad \\mathrm m^{2}/day$\n* $\\kappa = 1.7 * 86400 \\quad \\mathrm J/day/m/K$\n* $T_{steam} = 264 \\quad ^{\\circ}C$\n* $T_{reservoir} = 15 \\quad ^{\\circ}C$\n* $A = 40000 \\quad \\mathrm m^{2}$\n\nIt is assumed that the steam chamber moves downward at a speed of 1.5 m/year.\n\nThe annual total heat stored ahead of the front at transient state in 10 years is calculated as follows:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nt = range(0, 10 * 365) * 1.0 # days\nU = 1.5 / 365\nα = 8.333e-7 * 86400\nt_star = U * U .* t / α\nkappa = 1.7 * 86400\nT_steam = 264\nT_reservoir = 15\nA = 40000\n# calculate the cumulative heat stored ahead of the front in overburden in MJoules\nQ = A * cumulative_heat_flux_stored_transient(U, kappa, T_steam, T_reservoir, t_star) / 1e6 # MJ\n# create a DataFrame to store the results\ndf = DataFrame(t = t, year = t / 365.0, Q = Q);\n```\n:::\n\n\nThe annual cumulative heat stored ahead of the front at transient state in 10 years is calculated as follows:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ndf_sub = df[df.year .== round.(df.year, digits = 0), :]\n# create a lag column from Q column\ndf_sub[!, :Q_lag] = ShiftedArrays.lag(df_sub.Q, 1)\n# calculate the increamental heat loss to overburden\ndf_sub[!, :Q_incremental] = df_sub.Q - df_sub.Q_lag\n@df df_sub bar(:year, :Q_incremental, xlabel = \"Time (Year)\", ylabel = \"Annual heat stored ahead of the front (MJoules)\",\ntitle = \"Annual Cumulative Heat Stored Ahead of the Front\", lw = 3, label = L\"A = 40000 m^{2}\")\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](index_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\n## Conclusion\n\nIn this post, we showed that the maximum accumulated heat ahead of a moving front is equal to the steady state value. In many practical cases, the energy accumulation ahead of the steam front is close to the steady state value.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}